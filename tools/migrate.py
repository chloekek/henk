#!/usr/bin/env python3

"""
Run migrations to keep the database schema up to date.

Expects PGHOST to be set.
"""

from __future__ import annotations

import click
import os
import psycopg2  # type: ignore
import sys

from typing import Iterable, List, NamedTuple, Optional 
from collections import defaultdict


class MigrationDef(NamedTuple):
    seq_no: int
    name: str
    fname: str


def list_migrations() -> Iterable[MigrationDef]:
    for fname in os.listdir("migrations"):
        if not fname.endswith(".sql"):
            continue

        seq_no_str, name = fname.split("-", maxsplit=1)
        yield MigrationDef(int(seq_no_str), name.removesuffix(".sql"), fname)


def validate_migrations(defs: List[MigrationDef]) -> None:
    """
    Validate that:
    * The migration numbers form a contiguous range (no number is missing).
    * Every migration has a unique sequence number (no duplicate numbers).
    """
    by_number = defaultdict(lambda: [])

    for mig_def in defs:
        by_number[mig_def.seq_no].append(mig_def)

    for i in range(1, 1 + len(defs)):
        n = len(by_number[i])
        if n == 0:
            print(f"Error: Migration {i} is missing.")
            sys.exit(1)
        elif n == 1:
                continue
        else:
            print(f"Error: Migration {i} is not unique:")
            for mig_def in by_number[i]:
                print(f"  {mig_def.fname}")
            sys.exit(1)


        connection=psycopg2.connect("dbname=hanson user=hanson_setup password=hanson_setup")


def transaction() -> psycopg2.extensions.connection:
    return psycopg2.connect("dbname=hanson user=hanson_setup password=hanson_setup")


class App(NamedTuple):
    revisions: List[MigrationDef]

    @staticmethod
    def new() -> App:
        revisions = sorted(list_migrations())
        validate_migrations(revisions)
        return App(revisions)

    def get_current_revision(self) -> int:
        try:
            with transaction() as tx:
                with tx.cursor() as cur:
                    cur.execute(
                        """
                        SELECT revision
                        FROM _schema_migrations
                        ORDER BY id DESC
                        LIMIT 1;
                        """
                    )
                    result = cur.fetchone()
                    if result is None:
                        return 0
                    else:
                        return result[0]

        except psycopg2.errors.UndefinedTable:
            with transaction() as tx:
                with tx.cursor() as cur:
                    cur.execute(
                        """
                        CREATE TABLE _schema_migrations
                          ( id       BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY
                          , revision BIGINT NOT NULL
                          , created  TIMESTAMPTZ NOT NULL DEFAULT now()
                          );
                        """
                    )
                tx.commit()
                return 0

    def parse_revision_spec(self, current: int, spec: str) -> int:
        if spec == "latest":
            return self.revisions[-1].seq_no

        elif spec.isdigit():
            return int(spec)

        elif spec.startswith("+") and spec[1:].isdigit():
            rel = int(spec[1:])
            return current + rel

        elif spec.startswith("-") and spec[1:].isdigit():
            rel = int(spec[1:])
            return current - rel

        else:
            print(f"Invalid revision specification: {spec}")
            sys.exit(1)


@click.group()
def main():
    pass


@main.command()
@click.argument("revision_spec", default="latest")
def migrate(revision_spec: str) -> None:
    """
    Migrate to a particular revision. Supported revision specifiers are:

    * An exact number, e.g. "12". Will upgrade or downgrade depending on the
      current revision.

    * A relative offset, e.g. "+1" or "-1". Will upgrade or downgrade this
      number of revisions relative to the current revision.

    * The "latest", which upgrades to the revision with the highest revision
      number. This is the default.
    """
    app = App.new()

    current = app.get_current_revision()
    new_rev = app.parse_revision_spec(current, revision_spec)

    if new_rev < 0:
        print("Error: Revision numbers must not be negative.")
        sys.exit(1)

    elif new_rev > len(app.revisions):
        print(f"Error: Revision {new_rev} does not exist, max is {len(app.revisions)}.")
        sys.exit(1)

    if new_rev > current:
        print(f"Upgrading: {current} -> {new_rev}")
        # TODO: Run upgrades.
    elif new_rev < current:
        print(f"Downgrading: {current} -> {new_rev}")
        # TODO: Run downgrades.
    else:
        print(f"Already at target version: {current}")


@main.command()
def list():
    """
    Print all known migrations.
    """
    migrations = sorted(list_migrations())
    validate_migrations(migrations)
    for i, name in reversed(migrations):
        print(f"{i:04} {name}")


if __name__ == "__main__":
    main()
